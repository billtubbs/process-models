function eqs = crane_DAEs(t,Y,YP,params)
% eqs = crane_DAEs(t,Y,YP,params)
% Differential algebraic equations (DAEs) for the 
% dynamic model of a gantry crane system.
%
% This function can be used with the MATLAB ode15i
% solver to simulate the system.
%
% Arguments:
%   t : double
%       Time.
%   Y : (11, 1) double vector
%       System outpus, y(t), defined:
%           y(1) : horizontal position of cart, x(t), left to right
%           y(2) : angle of pole, theta(t), clockwise from vertical
%           y(3) : downward force of cart on track, N_c(t)
%           y(4) : horizontal friction force on cart by track, F_f(t)
%           y(5) : aerodynamic drag force on pendulum mass, F_d(t)
%           y(6) : horizontal component of force on arm by cart, N_x(t)
%           y(7) : vertical component of force on arm by cart, N_y(t)
%           y(8) : horizontal velocity of pendulum mass, v_x(t)
%           y(9) : vertical velocity of pendulum mass, v_y(t)
%           y(10) : horizontal velocity of cart, Dxt(t), left to right
%           y(11) : angular velocity of pole, Dthetat(t), clockwise.
%   YP : (11, 1) double vector
%       Partial derivatives of y(t).
%   params : struct
%       Parameter values defined:
%           params.F : Force acting on cart (  +  ve to right)
%           params.L : Pendulum length
%           params.c_d : Drag coefficient of load
%           params.g : Acceleration due to gravity (  +  ve down)
%           params.m_c : Cart mass
%           params.m_p : Pole mass
%           params.muc : Coefficient of friction for cart and track 
%           params.r : Dadius of load
%           params.rho : Density of air.
% 
% The equations below were generated by the MATLAB
% Symbolic Math Toolbox version 9.0. 13 - Feb - 2023. See
% livescript 'solve_DAE_crane.mlx'.
% 

    % Output variables
    %x = Y(1,:);  % x(t) has no effect
    theta = Y(2,:);
    N_c = Y(3,:);
    F_f = Y(4,:);
    F_d = Y(5,:);
    N_x = Y(6,:);
    N_y = Y(7,:);
    v_x = Y(8,:);
    v_y = Y(9,:);
    Dxt = Y(10,:);
    Dthetat = Y(11,:);

    % Partial derivatives
    YP1 = YP(1,:);
    YP2 = YP(2,:);
    YP10 = YP(10,:);
    YP11 = YP(11,:);

    % Parameters
    F = params.F;
    L = params.L;
    c_d = params.c_d;
    g = params.g;
    m_c = params.m_c;
    m_p = params.m_p;
    muc = params.muc;
    r = params.r;
    rho = params.rho;

    % Temporary variables
    cos_theta = cos(theta);
    sin_theta = sin(theta);
    mcmp = m_c + m_p;
    Dthetat_sq = Dthetat.^2;
    r_sq = r.^2;
    v_x_sq = v_x.^2;
    v_y_sq = v_y.^2;
    inv_mcmp = 1.0 ./ mcmp;
    
    % Compute DAEs
    eqs = nan(11, 1);

    eqs(1) = - Dxt + v_x - Dthetat .* L .* cos_theta;

    eqs(2) = v_y - Dthetat .* L .* sin_theta;

    eqs(3) = F_d - (c_d .* rho .* r_sq .* pi .* (v_x_sq + v_y_sq)) ./ 2.0;

    eqs(4) = N_x - m_p .* ( ...
        YP10 + YP11 .* L .* cos_theta - L .* sin_theta .* Dthetat_sq ...
    );

    eqs(5) = ( ...
        N_y ...
        - m_p .* (g - L .* (YP11 .* sin_theta + cos_theta .* Dthetat_sq)) ...
    );

    eqs(6) = N_c - N_y - g .* m_c;

    eqs(7) = F_f - N_c .* muc .* sign(Dxt .* N_c);

    eqs(8) = YP10 + inv_mcmp .* ( ...
        F_f ...
        - F ...
        + L .* m_p .* (YP11 .* cos_theta - sin_theta .* Dthetat_sq) ...
    );

    eqs(9) = ( ...
        - YP11 ...
        + ( ...
            ( ...
                cos_theta .* ( ...
                    m_p .* inv_mcmp .* ( ...
                        - F_f + F + L .* m_p .* sin_theta .* Dthetat_sq ...
                    ) ...
                    + (c_d .* rho .* r_sq .* v_x_sq .* pi .* sign(v_x)) ./ 2.0 ...
                ) ...
                - sin_theta .* ( ...
                    g .* m_p ...
                    - (c_d .* rho .* r_sq .* v_y_sq .* pi .* sign(v_y)) ./ 2.0 ...
                ) ...
            ) .* (3.0 ./ 4.0) ...
        ) ./ (L .* m_p .* (m_p .* cos_theta.^2 .* inv_mcmp .* (3.0 ./ 4.0) - 1.0)) ...
    );

    eqs(10) = Dxt - YP1;

    eqs(11) = Dthetat - YP2;

end
